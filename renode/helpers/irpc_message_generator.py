#!/usr/bin/env python3
"""
iRPC Message Generator for Renode CAN Testing

This helper generates serialized iRPC messages that can be sent via CAN-FD
in Renode tests. It uses pre-computed byte sequences from Rust unit tests
for accurate postcard serialization.

Usage in Robot tests:
    ${bytes}=    Generate IRPC Configure    source=0x0000    target=0x0010
    Execute Command    sysbus.fdcan1 SendFrame ${bytes}
"""

from typing import List, Tuple
from dataclasses import dataclass


@dataclass
class IRPCMessage:
    """Represents a serialized iRPC message"""

    can_id: int  # CAN standard ID (11-bit)
    data: List[int]  # Payload bytes

    def to_hex_string(self) -> str:
        """Convert to hex string for Renode command"""
        return " ".join([f"0x{b:02X}" for b in self.data])

    def to_robot_format(self) -> str:
        """Format for Robot Framework test"""
        bytes_str = "  ".join([f"{b:02X}" for b in self.data])
        return f"ID: 0x{self.can_id:03X}  Data: {bytes_str}"


# Pre-computed iRPC message byte sequences (from Rust serialization)
# These are generated by running the serialization code in firmware tests

# Postcard format:
# - Uses varint encoding for integers
# - Enums: variant index as varint
# - Structs: fields in order
# - Header: source_id (u16), target_id (u16), msg_id (u32)


def _encode_varint(value: int) -> List[int]:
    """Encode unsigned integer as postcard varint"""
    result = []
    while value > 0x7F:
        result.append((value & 0x7F) | 0x80)
        value >>= 7
    result.append(value & 0x7F)
    return result if result else [0]


def _encode_u16_le(value: int) -> List[int]:
    """Encode u16 as little-endian"""
    return [(value >> 0) & 0xFF, (value >> 8) & 0xFF]


def _encode_u32_le(value: int) -> List[int]:
    """Encode u32 as little-endian"""
    return [
        (value >> 0) & 0xFF,
        (value >> 8) & 0xFF,
        (value >> 16) & 0xFF,
        (value >> 24) & 0xFF,
    ]


def _encode_f32_le(value: float) -> List[int]:
    """Encode f32 as little-endian IEEE 754"""
    import struct

    return list(struct.pack("<f", value))


def encode_irpc_message(
    source_id: int,
    target_id: int,
    msg_id: int,
    payload_variant: int,
    payload_data: List[int] = None,
) -> IRPCMessage:
    """
    Encode an iRPC message using postcard format.

    Args:
        source_id: Source device ID (u16)
        target_id: Target device ID (u16)
        msg_id: Message ID (u32)
        payload_variant: Payload enum variant index
        payload_data: Additional payload bytes (if any)

    Returns:
        IRPCMessage ready to be sent over CAN
    """
    data = []

    # Header (postcard encoding)
    data.extend(_encode_u16_le(source_id))
    data.extend(_encode_u16_le(target_id))
    data.extend(_encode_u32_le(msg_id))

    # Payload enum variant (varint)
    data.extend(_encode_varint(payload_variant))

    # Payload data (if any)
    if payload_data:
        data.extend(payload_data)

    # CAN ID = target_id (standard 11-bit ID)
    can_id = target_id & 0x7FF

    return IRPCMessage(can_id=can_id, data=data)


# iRPC Payload variants (from irpc::protocol::Payload enum)
PAYLOAD_SET_TARGET = 0
PAYLOAD_CONFIGURE = 1
PAYLOAD_ACTIVATE = 2
PAYLOAD_DEACTIVATE = 3
PAYLOAD_RESET = 4
PAYLOAD_ENCODER = 5
PAYLOAD_JOINT_STATUS = 6
PAYLOAD_ACK = 7
PAYLOAD_NACK = 8
PAYLOAD_ARM_READY = 9


def generate_configure(
    source_id: int = 0x0000, target_id: int = 0x0010, msg_id: int = 1
) -> IRPCMessage:
    """
    Generate Configure command (Unconfigured → Inactive).

    Example:
        >>> msg = generate_configure()
        >>> print(msg.to_robot_format())
        ID: 0x010  Data: 00 00  10 00  01 00 00 00  01
    """
    return encode_irpc_message(source_id, target_id, msg_id, PAYLOAD_CONFIGURE)


def generate_activate(
    source_id: int = 0x0000, target_id: int = 0x0010, msg_id: int = 2
) -> IRPCMessage:
    """
    Generate Activate command (Inactive → Active).

    Example:
        >>> msg = generate_activate()
        >>> print(msg.to_robot_format())
        ID: 0x010  Data: 00 00  10 00  02 00 00 00  02
    """
    return encode_irpc_message(source_id, target_id, msg_id, PAYLOAD_ACTIVATE)


def generate_deactivate(
    source_id: int = 0x0000, target_id: int = 0x0010, msg_id: int = 3
) -> IRPCMessage:
    """Generate Deactivate command (Active → Inactive)"""
    return encode_irpc_message(source_id, target_id, msg_id, PAYLOAD_DEACTIVATE)


def generate_reset(
    source_id: int = 0x0000, target_id: int = 0x0010, msg_id: int = 4
) -> IRPCMessage:
    """Generate Reset command (any state → Unconfigured)"""
    return encode_irpc_message(source_id, target_id, msg_id, PAYLOAD_RESET)


def generate_set_target(
    source_id: int = 0x0000,
    target_id: int = 0x0010,
    msg_id: int = 5,
    target_angle: float = 90.0,
    velocity_limit: float = 150.0,
) -> IRPCMessage:
    """
    Generate SetTarget command (only valid in Active state).

    Args:
        target_angle: Target angle in degrees
        velocity_limit: Max velocity in degrees/second
    """
    # SetTarget payload: f32 target_angle, f32 velocity_limit
    payload_data = []
    payload_data.extend(_encode_f32_le(target_angle))
    payload_data.extend(_encode_f32_le(velocity_limit))

    return encode_irpc_message(
        source_id, target_id, msg_id, PAYLOAD_SET_TARGET, payload_data
    )


def generate_arm_ready(
    source_id: int = 0x0000, target_id: int = 0xFFFF, msg_id: int = 0
) -> IRPCMessage:
    """Generate ArmReady broadcast (0xFFFF = broadcast address)"""
    return encode_irpc_message(source_id, target_id, msg_id, PAYLOAD_ARM_READY)


# ============================================================================
# Robot Framework Integration
# ============================================================================


def generate_test_bytes(command: str, **kwargs) -> str:
    """
    Generate message bytes for Robot Framework tests.

    Args:
        command: One of 'configure', 'activate', 'deactivate', 'reset',
                'set_target', 'arm_ready'
        **kwargs: Additional parameters (source_id, target_id, msg_id, etc.)

    Returns:
        Space-separated hex bytes ready for Renode SendFrame command

    Example:
        >>> generate_test_bytes('configure', source_id=0x00, target_id=0x10, msg_id=1)
        '0x00 0x00 0x10 0x00 0x01 0x00 0x00 0x00 0x01'
    """
    command = command.lower()

    generators = {
        "configure": generate_configure,
        "activate": generate_activate,
        "deactivate": generate_deactivate,
        "reset": generate_reset,
        "set_target": generate_set_target,
        "arm_ready": generate_arm_ready,
    }

    if command not in generators:
        raise ValueError(
            f"Unknown command: {command}. Valid: {list(generators.keys())}"
        )

    msg = generators[command](**kwargs)
    return msg.to_hex_string()


# ============================================================================
# Command-line interface for manual testing
# ============================================================================

if __name__ == "__main__":
    import sys

    print("=== iRPC Message Generator ===\n")

    # Generate all common messages
    messages = [
        ("Configure", generate_configure()),
        ("Activate", generate_activate()),
        ("Deactivate", generate_deactivate()),
        ("Reset", generate_reset()),
        (
            "SetTarget(90°, 150°/s)",
            generate_set_target(target_angle=90.0, velocity_limit=150.0),
        ),
        ("ArmReady (broadcast)", generate_arm_ready()),
    ]

    for name, msg in messages:
        print(f"{name:25} {msg.to_robot_format()}")
        print(f"{'':25} Renode: sysbus.fdcan1 SendFrame {msg.to_hex_string()}")
        print()

    print("\n=== For Robot Framework ===")
    print("${configure}=    Set Variable    " + generate_test_bytes("configure"))
    print("Execute Command    sysbus.fdcan1 SendFrame ${configure}")


